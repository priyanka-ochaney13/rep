import React, { createContext, useContext, useReducer, useEffect, useCallback } from 'react';
import { generateDocs } from '../api/apiClient';
import { useAuth } from '../context/AuthContext';

// --- Types / Constants --------------------------------------------------
// Status flow: Pending -> Processing -> Ready | Failed

const INITIAL_SEED = [
  {
    id: 'seed-dsa-prac',
    name: 'DSA-prac',
    owner: 'priyanka-ochaney13',
    description: 'Practice data structures & algorithms.',
    stars: 0,
    lang: 'JavaScript',
    status: 'Ready',
    updatedAt: '2025-10-04',
    docs: {
      readme: '# DSA-prac\n\nThis repository contains data structure & algorithm practice solutions.\n',
      summary: 'Includes solutions for arrays, graphs, trees, and more.',
      changelog: [
        { date: '2025-10-04', entry: 'Added new graph algorithms.' },
        { date: '2025-09-20', entry: 'Refactored tree traversal utilities.' },
        { date: '2025-09-01', entry: 'Initial auto-generated docs.' }
      ]
    }
  },
  {
    id: 'seed-repox',
    name: 'repox',
    owner: 'priyanka-ochaney13',
    description: 'RepoX core service.',
    stars: 0,
    lang: 'TypeScript',
    status: 'Ready',
    updatedAt: '2025-10-04',
    docs: { readme: '# RepoX\nCore service powering automated documentation.\n', summary: 'Core logic & automation pipeline.', changelog: [] }
  },
  {
    id: 'seed-api-gateway',
    name: 'api-gateway',
    owner: 'acme',
    description: 'Scalable API gateway with rate limiting and authentication',
    stars: 156,
    lang: 'Go',
    status: 'Ready',
    updatedAt: '2024-01-14',
    docs: { readme: '# API Gateway\nHigh-performance gateway written in Go.\n', summary: 'Gateway modules & middleware overview.', changelog: [] }
  }
];

// Get storage key for specific user
function getStorageKey(userEmail) {
  if (!userEmail) return 'repox.repos.v1.guest';
  return `repox.repos.v1.${userEmail}`;
}

function todayISO() { return new Date().toISOString().split('T')[0]; }

// Helper function to detect languages from file summaries
function detectLanguagesFromSummaries(summaries) {
  if (!summaries || typeof summaries !== 'object') return 'Unknown';
  
  const languageCount = {};
  const extensionMap = {
    '.py': 'Python',
    '.js': 'JavaScript',
    '.jsx': 'JavaScript',
    '.ts': 'TypeScript',
    '.tsx': 'TypeScript',
    '.java': 'Java',
    '.cpp': 'C++',
    '.c': 'C',
    '.go': 'Go',
    '.rs': 'Rust',
    '.rb': 'Ruby',
    '.php': 'PHP',
    '.swift': 'Swift',
    '.kt': 'Kotlin',
    '.cs': 'C#',
    '.html': 'HTML',
    '.css': 'CSS',
    '.scss': 'SCSS',
  };
  
  // Count files by extension
  Object.keys(summaries).forEach(filename => {
    const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
    const lang = extensionMap[ext];
    if (lang) {
      languageCount[lang] = (languageCount[lang] || 0) + 1;
    }
  });
  
  // Get languages sorted by count
  const sortedLangs = Object.entries(languageCount)
    .sort(([,a], [,b]) => b - a)
    .map(([lang]) => lang);
  
  // Return top 2-3 languages
  if (sortedLangs.length === 0) return 'Unknown';
  if (sortedLangs.length === 1) return sortedLangs[0];
  if (sortedLangs.length === 2) return sortedLangs.join(', ');
  return sortedLangs.slice(0, 2).join(', ') + ' +' + (sortedLangs.length - 2);
}

// --- Reducer ------------------------------------------------------------

const ACTIONS = {
  LOAD: 'LOAD',
  ADD: 'ADD',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

function repoReducer(state, action) {
  switch (action.type) {
    case ACTIONS.LOAD:
      return action.payload;
    case ACTIONS.ADD:
      return [action.payload, ...state];
    case ACTIONS.UPDATE:
      return state.map(r => r.id === action.id ? { ...r, ...action.patch, docs: { ...r.docs, ...(action.patch.docs || {}) } } : r);
    case ACTIONS.DELETE:
      return state.filter(r => r.id !== action.id);
    default:
      return state;
  }
}

const RepoContext = createContext(null);

export function RepoProvider({ children }) {
  const [repos, dispatch] = useReducer(repoReducer, []);
  const { user } = useAuth();
  const currentStorageKey = getStorageKey(user?.email);

  // Load from localStorage when user changes or on mount
  useEffect(() => {
    try {
      const raw = localStorage.getItem(currentStorageKey);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          console.log(`ðŸ“‚ Loaded ${parsed.length} repos for user:`, user?.email || 'guest');
          dispatch({ type: ACTIONS.LOAD, payload: parsed });
          return;
        }
      }
    } catch { /* ignore */ }
    
    // For logged-in users, start with empty array (they add their own repos)
    // For guests (not logged in), show sample data
    if (user) {
      console.log('ðŸ“‚ Starting with empty repos for new user:', user.email);
      dispatch({ type: ACTIONS.LOAD, payload: [] });
    } else {
      console.log('ðŸ“‚ Loading sample data for guest user');
      dispatch({ type: ACTIONS.LOAD, payload: INITIAL_SEED });
    }
  }, [user?.email, currentStorageKey]);

  // Persist anytime repos changes
  useEffect(() => {
    if (repos.length >= 0) { // Allow saving even empty arrays
      console.log('ðŸ’¾ Saving to localStorage:', repos.length, 'repos for', user?.email || 'guest');
      try { 
        localStorage.setItem(currentStorageKey, JSON.stringify(repos)); 
      } catch (err) { 
        console.error('âŒ Failed to save to localStorage:', err);
      }
    }
  }, [repos, currentStorageKey, user?.email]);

  // --- Actions ---------------------------------------------------------

  const updateRepo = React.useCallback((id, patch) => {
    dispatch({ type: ACTIONS.UPDATE, id, patch });
  }, []);

  const simulateGeneration = React.useCallback(async (id, githubUrl, owner, name, commitToGithub = false) => {
    updateRepo(id, { status: 'Processing' });
    
    try {
      // Call the backend API to generate documentation
      const result = await generateDocs({
        inputType: 'url',
        inputData: githubUrl,
        branch: 'main',
        commitToGithub: commitToGithub
      });
      
      console.log('âœ… Documentation generated successfully:', result);
      console.log('ðŸ“Š README length:', result.readme?.length || 0);
      console.log('ðŸ“Š Summaries:', result.summaries);
      console.log('ðŸ“Š Summaries count:', Object.keys(result.summaries || {}).length);
      
      // Detect languages from the code summaries
      const detectedLanguages = detectLanguagesFromSummaries(result.summaries);
      console.log('ðŸ” Detected languages:', detectedLanguages);
      
      // Update repo with the generated documentation
      const updatedDocs = {
        status: 'Ready',
        lang: detectedLanguages, // Update with detected languages
        docs: {
          readme: result.readme || '',
          summary: result.summaries || 'Automated summary generated on ' + new Date().toLocaleString(),
          changelog: [{ date: todayISO(), entry: 'Initial auto-generated docs.' }],
          visuals: result.visuals || null,
          folderTree: result.folder_tree || null,
          projectAnalysis: result.project_analysis || null, // Add project analysis
        },
        commitStatus: result.commit_status,
        commitMessage: result.commit_message,
      };
      
      console.log('ðŸ’¾ Saving docs to store:', updatedDocs.docs);
      
      updateRepo(id, updatedDocs);
      
      // Wait a bit to ensure localStorage is updated before navigating
      setTimeout(() => {
        console.log('ðŸ“ Navigating to docs page...');
        window.location.href = `/docs/${owner}/${name}`;
      }, 500);
    } catch (error) {
      console.error('âŒ Generation failed:', error);
      updateRepo(id, { status: 'Failed' });
    }
  }, [updateRepo]);

  const fetchGitHubMeta = React.useCallback(async (id, owner, name) => {
    try {
      const res = await fetch(`https://api.github.com/repos/${owner}/${name}`);
      if (!res.ok) return; // rate limit or not found
      const json = await res.json();
      updateRepo(id, {
        stars: json.stargazers_count || 0,
        lang: json.language || 'Unknown',
        description: json.description || '',
        updatedAt: json.updated_at ? json.updated_at.split('T')[0] : todayISO()
      });
    } catch { /* ignore network errors */ }
  }, [updateRepo]);

  const connectRepo = React.useCallback(async (githubUrl, manual = {}) => {
    let owner, name;
    try {
      const u = new URL(githubUrl);
      if (u.hostname !== 'github.com') throw new Error('Not GitHub');
      const parts = u.pathname.split('/').filter(Boolean);
      if (parts.length < 2) throw new Error('Bad path');
      [owner, name] = parts;
    } catch {
      return { error: 'Invalid GitHub URL' };
    }
    const id = `${owner}-${name}-${Date.now()}`;
    const newRepo = {
      id,
      name,
      owner,
      description: manual.description || '',
      stars: 0, // Will be fetched from GitHub API
      lang: 'Detecting...', // Will be updated from GitHub API or parsed data
      status: 'Pending',
      updatedAt: todayISO(),
      docs: {
        readme: `# ${name}\n\nAuto-generated placeholder README.\n`,
        summary: '',
        changelog: []
      }
    };
    dispatch({ type: ACTIONS.ADD, payload: newRepo });
    // Kick off async tasks
    simulateGeneration(id, githubUrl, owner, name, manual.commitToGithub || false);
    fetchGitHubMeta(id, owner, name);
    return { id };
  }, [simulateGeneration, fetchGitHubMeta]);

  const retryGeneration = React.useCallback((id) => {
    const repo = repos.find(r => r.id === id);
    if (!repo) return;
    
    const githubUrl = `https://github.com/${repo.owner}/${repo.name}`;
    updateRepo(id, { status: 'Pending' });
    // Retry without commit to GitHub by default (user can reconnect if they want to commit)
    simulateGeneration(id, githubUrl, repo.owner, repo.name, false);
  }, [simulateGeneration, updateRepo, repos]);

  const deleteRepo = React.useCallback((id) => {
    dispatch({ type: ACTIONS.DELETE, id });
  }, []);

  const value = {
    repos,
    connectRepo,
    updateRepo,
    retryGeneration,
    deleteRepo
  };

  return <RepoContext.Provider value={value}>{children}</RepoContext.Provider>;
}

export function useRepos() {
  const ctx = useContext(RepoContext);
  if (!ctx) throw new Error('useRepos must be used within RepoProvider');
  return ctx;
}
